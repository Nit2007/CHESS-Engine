allinit();
    
    uint64_t bb=0ULL;
    PrintBitBoard(bb);   //print12064();
    //bb=8ULL;
    
    int sq120=getSquareFromString("d2");
    bb|=(1ULL<<SQ64(sq120));
    cout<<"COUNT : "<<countBitBoard(bb)<<endl;
    PrintBitBoard(bb);  

    sq120=getSquareFromString("d3");
    bb|=(1ULL<<SQ64(sq120));
    cout<<"COUNT : "<<countBitBoard(bb)<<endl;
    PrintBitBoard(bb);

    sq120=getSquareFromString("d4");
    bb|=(1ULL<<SQ64(sq120));
    cout<<"COUNT : "<<countBitBoard(bb)<<endl;
    PrintBitBoard(bb);

    sq120=getSquareFromString("d7");
    bb|=(1ULL<<SQ64(sq120));
    cout<<"COUNT : "<<countBitBoard(bb)<<endl;
    PrintBitBoard(bb);

    cout<<"POPPED : "<<popBitBoard(&bb)<<endl; PrintBitBoard(bb);
    cout<<"POPPED : "<<popBitBoard(&bb)<<endl; PrintBitBoard(bb);
    cout<<"POPPED : "<<popBitBoard(&bb)<<endl; PrintBitBoard(bb);
    uint64_t bp=0ULL;
    initBitMask();
   setBit(bp,60);PrintBitBoard(bp);
   clearBit(bp,60); PrintBitBoard(bp);
    //ASSERT(5==4);

//PARSE FEN 
allinit();
s_board B;
    Parse_FEN((char*)START_FEN, &B); // cast and address-of for pointer
    PrintBoard(&B);
    Parse_FEN((char*)FEN_1, &B);
    PrintBoard(&B);
    Parse_FEN((char*)FEN_2, &B);
    PrintBoard(&B);
    Parse_FEN((char*)FEN_3, &B);
    PrintBoard(&B);


//TO PRINT PAWNS OF FEN POSITION
allinit();
    s_board B;
    Parse_FEN((char*)START_FEN, &B); 
    UpdatePieceList(&B);          
    PrintBoard(&B);               
    cout << endl << "Pawns" << endl;
    PrintBitBoard(B.pawns[WHITE]);  
    PrintBitBoard(B.pawns[BLACK]); cout << endl;
    PrintBitBoard(B.pawns[BOTH]);  cout << endl;
/*allinit();  //BY USING POINTER (MORE READABILITY)
    s_board *B=new s_board;
    Parse_FEN((char*)START_FEN, B); 
    UpdatePieceList(B);          
    PrintBoard(B);               
    cout << endl << "Pawns" << endl;
    PrintBitBoard(B->pawns[WHITE]);  
    PrintBitBoard(B->pawns[BLACK]); cout << endl;
    PrintBitBoard(B->pawns[BOTH]);  cout << endl;*/

//to verify CheckBoard(const s_board* pos) 
s_board pos;
     printf("Testing CheckBoard function...\n\n");
    
    // TEST 1: Valid starting position (should PASS)
    printf("Test 1: Valid starting position\n");
    Parse_FEN((char*)START_FEN, &pos);
    UpdatePieceList(&pos);
    if(CheckBoard(&pos)) {
        printf("✓ PASSED: Starting position is valid\n");
    } else {
        printf("✗ FAILED: Starting position should be valid\n");
    }

//for checking the attack.cpp functions
allinit();
    s_board  pos;
     Parse_FEN((char*)FEN_4,&pos);
     UpdatePieceList(&pos);   
     PrintBoard(&pos);
     showSqAttackBySide(WHITE,&pos);

//Printing Move in different format
int from = 26;
    int to = 28;
    int cap=WR;int prom=BQ;
    int move=0;
    move= ( from | (to << 7) | (cap <<14) | (prom << 20)) ; 
    cout<<"Integer : "<< move<<endl;
    cout<<"Binary : ";
    PrintBin(move);cout<<endl<<"Castled Binary : ";
    move |= MFLAGCA;
    PrintBin(move);
    printf("\nDecimal : %d \n Hexadecimal : %x",move ,move);
cout<< endl<<((move & MFLAGCA) ? "Castled" :"Not castled");
//to print square ,promotion in int move
   cout<<PrSq(A2)<<"->";
    cout<<PrSq(G7)<<endl;
    cout<<PrMove(move);


//TO CHECK GENERATE ALL PAWN MOVES FOR wHITE
    allinit();
    s_board board;
    Parse_FEN((char*)PAWNMOVES_FEN,&board);//Parse_FEN((char*)PAWNMOVES_B_FEN,&board);
    PrintBoard(&board);
    s_movelist list;
    GenerateAllMoves(&board,&list);
    PrintMoveList(&list);


//INPUT TO CHECK makemove AND movegen for START_FEN
    allinit();
    s_board board;
    Parse_FEN((char*)START_FEN,&board);
    PrintBoard(&board);
    s_movelist list;
    GenerateAllMoves(&board,&list);
    PrintMoveList(&list);
    getchar();
    for(int movenum=0;movenum<list.count;movenum++)
    {
        int move=list.moves[movenum].move;
        if(!MakeMove(&board,move))continue;
        cout<<"Made : "<<PrMove(move)<<endl;
        PrintBoard(&board);
        TakeMove(&board);
        cout<<"Taken : "<<PrMove(move)<<endl;
        PrintBoard(&board);
        getchar();
    }



//to check GetHashLine
allinit();
    s_board board;
    Parse_FEN((char*)FEN_2,&board);
    PrintBoard(&board);
    s_movelist list;
    GenerateAllMoves(&board,&list);
    PrintMoveList(&list);
    s_searchinfo* info = new s_searchinfo;
    info->depth = 6; // Set search depth
    ClearForSearch(&board,info);
    SearchPosition(&board,info);




cout << "Chess Engine - Choose Mode:" << endl;
    cout << "1. Console Mode (for testing)" << endl;
    cout << "2. UCI Mode (for Lichess, ChessBase)" << endl;
    cout << "3. xBoard Mode (for xBoard/WinBoard)" << endl;
    cout << "Enter choice (1-3): ";
int choice;
    cin >> choice;
    cin.ignore(); // Clear newline
// Initialize the engine
    allinit();
if (choice == 2) {
        cout << "Starting Chess Engine in UCI mode..." << endl;
        UCI_Init();
        UCI_Loop();
    }
    else if (choice == 3) {
        cout << "Starting Chess Engine in xBoard mode..." << endl;
        XBoard_Init();
        XBoard_Loop();
    }
    else {
        // Default console mode for testing
        cout << "Starting Chess Engine in Console mode..." << endl;
        s_board board;
        Parse_FEN((char*)FEN_2, &board);
        PrintBoard(&board);
        s_movelist list;
        GenerateAllMoves(&board, &list);
        PrintMoveList(&list);
        s_searchinfo* info = new s_searchinfo;
        info->depth = 6;
        ClearForSearch(&board, info);
        SearchPosition(&board, info);
        cout << endl << "*************end*************" << endl;
delete info;
    }